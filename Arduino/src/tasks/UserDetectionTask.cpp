#include <Arduino.h>
#include <avr/sleep.h>
#include <avr/io.h>
#include <avr/interrupt.h>
#include <avr/power.h>

#include "tasks/Task.h"
#include "Observer.h"
#include "tasks/UserDetectionTask.h"


UserDetectionTask::UserDetectionTask(PIR *userDetector, int interruptPin, unsigned long t)
    : userDetector(userDetector), interruptPin(interruptPin), timeout(t)
{
}

void UserDetectionTask::init(int period)
{
    if (!this->userDetector->isReady())
    {
        this->userDetector->startCalibrating();
        this->state = CALIBRATING;
    } else
    {
        this->state = DETECTED;
    }
    Task::init(period);
}

void UserDetectionTask::tick()
{
    //Serial.println(String(this->state));
    switch (this->state)
    {
        case CALIBRATING:
            // TODO: dont use a blocking operation but passively wait and enable all the other tasks once ready. other tasks start as deactivated.
            this->userDetector->waitCalibrationDone();  /* Blocking*/
            // passa a detected perche si. lo dice la consegna.
            this->state = DETECTED;
            this->notify(MOTION_DETECTED);
            //this->enableAllTasks();
            break;

        case DETECTING:
            // The system goes to sleep and waits for interrupt to wakeup. generated by PIR when user is nearby.
            this->sleep();

            // Woke up, user is near.
            this->state = DETECTED;
            this->notify(MOTION_DETECTED);
            break;

        case DETECTED:
            // se nn rileva movim passa a wait undetected.
            this->userDetector->sync();
            if (!this->userDetector->userDetected())
            {
                this->state = WAIT_UNDETECTED;
                this->timeUndetected = millis();
            }
            break;

        case WAIT_UNDETECTED:
            // Se rileva movimento torna a detected.
            this->userDetector->sync();
            if (this->userDetector->userDetected())
            {
                this->state = DETECTED;
            }
            // Altrimenti se non rileva movimento ed è passato abbastanza tempo torna a DETECTING, ovvero in sleep.
            else if (millis() - timeUndetected >= timeout)
            {
                this->state = DETECTING;
                this->notify(NO_MOTION);
            }
            break;
    }
}

void wakeUp()
{

}

void UserDetectionTask::sleep()
{
    attachInterrupt(digitalPinToInterrupt(this->interruptPin), wakeUp, RISING);
    set_sleep_mode(SLEEP_MODE_IDLE);    // Imposta la modalità sleep
    sleep_enable();                 // Abilita il sleep
    power_adc_disable();            // Disabilita l'ADC
    power_timer0_disable();         // Disabilita timer0
    power_timer1_disable();         // Disabilita timer1
    power_timer2_disable();         // Disabilita timer2
    sleep_mode();                   // Vai in sleep mode

    // La CPU si sveglierà quando viene generato un interrupt (PIR)
    sleep_disable();                 // Disabilita il sleep quando esci
    power_all_enable();              // Riabilita tutto quando esci dal sleep
    detachInterrupt(digitalPinToInterrupt(this->interruptPin));
}